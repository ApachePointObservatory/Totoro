# Licensed under a 3-clause BSD style license - see LICENSE.rst
"""
This module provides some functions and classes to add tiles to
mangaDB from a tiling catalogue.
"""

from __future__ import print_function
from ..plateDB.dataModel import *
from collections import OrderedDict
from sqlalchemy import func
from ..exceptions import GITSError


__all__ = ['addFromTilingCatalogue']


_TESTING_OPTIONS = OrderedDict([
    ('plate+location_id', -1),  # This is not used anyway
    ('plate+comment', 'manga_test'),
    ('plate+plate_location_pk', 0),
    ('plate+rerun', ''),
    ('plate+temperature', 0.0),
    ('plate+epoch', 2000.0),
    ('plate+chunk', 'manga_test'),
    ('plate+plate_completion_status_pk', 0),
    ('plate_run+label', 'manga_test'),
    ('plate_run+year', '2013'),
    ('tile+tile_status_pk', 0),
    ('pointing+pointing_no', 1),
    ('plate_pointing+pointing_name', 'A'),
    ('plate_pointing+ha_observable_min', None),
    ('plate_pointing+ha_observable_max', None),
    ('plate_pointing+priority', 4)])


# Grouping values for different indexes and keys
_TESTING_TILE_ID_ROOT = 20000
_TESTING_DESIGN_PK_ROOT = 9000
_TESTING_PLATE_ID_ROOT = 9000


def addFromTilingCatalogue(catalogue, testing=True, **options):
    """Reads a tiling catalogue and adds the information to plateDB.

    This function reads a tiling catalogue and uptates plateDB to include
    the tiles as plates in design phase. If testing is True, the remaining
    parameters are ignored and most fields are filled out with
    manga_test values.

    """

    session.rollback()
    catData = readTilingCatalogue(catalogue)

    if testing:
        options = _getTestingOptions()
        _AddFromTilingCatalogueTesting(catData, options)
    else:
        raise GITSError('testing=False not yet implemented. '
                        'That\'s embarrassing.')


def _AddFromTilingCatalogueTesting(catData, options):
    """Adds data from a tiling catalogue in testing mode."""

    for tile in catData:
        _addTile(tile, options, commit=False)
    session.commit()


def _addTile(tile, options, commit=True):
    """Adds a single tile to the database."""

    options['tile']['id'] = _TESTING_TILE_ID_ROOT + tile['ID']
    tilePK = createTile(options['tile'])

    options['design'] = {'pk': tile['ID']+_TESTING_DESIGN_PK_ROOT,
                         'comment': None}
    designPK = createDesign(options['design'])
    options['plate']['design_pk'] = designPK

    options['plate']['plate_id'] = _TESTING_PLATE_ID_ROOT + tile['ID']
    options['plate']['tile_id'] = options['tile']['id']
    options['plate']['tile_pk'] = tilePK
    options['plate']['name'] = 'manga_test_{0}'.format(
        options['tile']['id'])
    platePK = createPlate(options['plate'])

    options['pointing']['center_ra'] = tile['RA']
    options['pointing']['center_dec'] = tile['Dec']
    options['pointing']['design_pk'] = designPK
    pointing = Pointing(**options['pointing'])
    session.add(pointing)
    session.flush()

    options['plate_pointing'].update({
        'hour_angle': 0.0, 'plate_pk': platePK,
        'pointing_pk': pointing.pk})
    createPlatePointing(options['plate_pointing'])

    if commit:
        session.commit()

    return


def _AddOrUpdate(table, query, values):
    """Adds a record or updates an existing one.

    Gets a query. If it is empty, creates a new record
    with the input values. Otherwise, updates de query.

    """
    if query.count() > 0:
        query.update(values)
        session.flush()
        return query[0].pk
    else:
        newRecord = table(**values)
        session.add(newRecord)
        session.flush()
        return newRecord.pk


def createPlate(valueDic):
    """Adds or updates a plate."""
    plateID = valueDic['plate_id']
    tentativeQuery = session.query(Plate).filter(
        Plate.plate_id == plateID)
    return _AddOrUpdate(Plate, tentativeQuery, valueDic)


def createTile(valueDic):
    """Adds or updates a tile."""
    if valueDic['id'] is None:
        valueDic['id'] = session.query(func.max(Tile.id)) + 1
    tentativeQuery = session.query(Tile).filter(Tile.id == valueDic['id'])
    return _AddOrUpdate(Tile, tentativeQuery, valueDic)


def createDesign(valueDic):
    """Adds or updates a tile."""
    tentativeQuery = session.query(Design).filter(Design.pk == valueDic['pk'])
    return _AddOrUpdate(Design, tentativeQuery, valueDic)


def createPlatePointing(valueDic):
    """Adds or updates a plate pointing."""
    tentativeQuery = session.query(PlatePointing).filter(
        PlatePointing.plate_pk == valueDic['plate_pk'])
    if tentativeQuery.count() > 1:
        raise GITSError('Multiple plate pointing for plate {0}. '.format(
            tentativeQuery[0].plate_pk) +
            'This is unexpected')
    return _AddOrUpdate(PlatePointing, tentativeQuery, valueDic)


def readTilingCatalogue(catalogue, id='ID', ra='RA', dec='DEC'):
    """Reads a tiling catalogue in FITS format."""
    from astropy import table
    cat = table.Table.read(catalogue, format='fits')
    if id != 'ID':
        cat.rename_column(id, 'ID')
    if ra != 'RA':
        cat.rename_column(ra, 'RA')
    if dec != 'Dec':
        cat.rename_column(dec, 'Dec')
    return cat


def _getTestingOptions():
    options = _parseOptions(_TESTING_OPTIONS)
    plateRun = _getPlateRun(**options['plate_run'])
    options['plate']['plate_run_pk'] = plateRun.pk
    return options


def _getPlateRun(label, year):
    """Gets the pk of a certain plate run or creates a new record."""

    queryPlateRun = session.query(PlateRun).filter(
        PlateRun.label == label).filter(PlateRun.year == year)
    if queryPlateRun.count() > 0:
        return queryPlateRun[0]
    else:
        newPlateRun = PlateRun(label=label, year=year)
        session.add(newPlateRun)
        session.flush()
        return newPlateRun


def _parseOptions(rawDict):
    """
    Takes a raw dictionary with the format
    {'table+field1': value1, 'table+field2': value2, ...}
    and returns a dictionary with the format
    {'table': {'field1': value1, 'field2': value2, ...}, ...}

    """

    _returnDict = OrderedDict()
    for key, value in rawDict.items():
        table, field = key.split('+')
        if table not in _returnDict:
            _returnDict[table] = OrderedDict()
        _returnDict[table][field] = value
    return _returnDict
